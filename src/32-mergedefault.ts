/* eslint-disable no-undef, no-unused-vars, @typescript-eslint/no-unused-vars */

// Make it a module
export {}

/**
 * https://drive.google.com/drive/folders/0B5_WfYf1UaShNlpHUlVrREJwbVE
 * https://fettblog.eu/low-maintenance-types-typescript/
 *
 */

/**
 * Scenario 1: Information is already available
 */
type Options1 = {
	from: string
	to: string
}
const defaultOptions1: Options1 = { from: "src", to: "dst" }

function copy1(options: Partial<Options1>) {
	const allOptions = { ...defaultOptions1, ...options }
}

/**
 * 1A Problem: Adding another field, would have to adapt code in three places
 *
 * 1A Solution: Make use of the typeof operator in TypeScript to create a new
 * type on the fly
 */

const defaultOptions2 = { from: "src", to: "dst", overwrite: true }

function copy2(options: Partial<typeof defaultOptions2>) {
	const allOptions = { ...defaultOptions2, ...options }
}

/**
 * Scenario 2: Connected Models
 *
 * See also 8-unionintersectiontypes
 */
type ToyBase = {
	name: string
}

type BoardGame = ToyBase & {
	kind: "boardgame"
	players: number
}

type Puzzle = ToyBase & {
	kind: "puzzle"
	pieces: number
}

type Doll = ToyBase & {
	kind: "doll"
	material: "plastic" | "plush"
}

type Toy = BoardGame | Puzzle | Doll

type ToyKind1 = "boardgame" | "puzzle" | "doll"

type GroupedToys1 = {
	boardgame: Toy[]
	puzzle: Toy[]
	doll: Toy[]
}

/**
 * 2A Problem: Adding another type, would have to adapt code in three places
 *
 * 2A.1 Solution: If we want to have a union type ToyKind with all possible
 * kind types, it’s better to not maintain them on the side, but rather access
 * the types directly.
 */
type ToyKind2 = Toy["kind"] // (ok) "boardgame" | "puzzle" | "doll"

/**
 * 2A.2 Solution: We can use the newly created and self-maintaining ToyKind type
 *  to create a new, better GroupedToys type using mapped types.
 *
 * In our example, the property keys are generated by looping over the union type ToyKind2.
 *
 * See also 8-unionintersectiontypes EventKind2, TechEvent2 and GroupedEvents2.
 */
type GroupedToys2 = { [Kind in ToyKind2]: Toy[] }

/**
 * 2B Problem: The GroupedToys type is not exactly what we’re looking for. When we group
 * toys, we want to make sure that we only add Doll type objects to doll, etc.
 *
 * 2B.1 Solution: Extract all types that have the kind property set to Kind
 */
type GetKind<Group, Kind> = Extract<Group, { kind: Kind }>

type GetKind_Doll = GetKind<Toy, "doll"> // (ok)  type GetKindDoll = ToyBase & { kind: "doll"; ... }

type GroupedToys3 = { [Kind in ToyKind2]: GetKind<Toy, Kind>[] } // (ok) type GroupedToys3 = { boardgame: BoardGame[]; ... doll: Doll[]; }

/**
 * 2C Problem: But there’s one thing that still bugs me. The property keys. They’re singular.
 * They should be plural
 *
 * 2B.1 Solution: Use Template Literal Type at the as property position
 */

type GroupedToys4 = { [Kind in ToyKind2 as `${Kind}s`]: GetKind<Toy, Kind>[] } // (ok) type GroupedToys4 = { boardgames: BoardGame[]; ... dolls: Doll[]; }

function groupToys1(toys: Toy[]): GroupedToys4 {
	const grouped: GroupedToys4 = {
		boardgames: [],
		dolls: [],
		puzzles: [],
	}
	toys.forEach((el) => {
		grouped[`${el.kind}s` as const].push(el) // (nok) Type 'BoardGame' is not assignable to type 'never'.ts(2345)
	})
	return grouped
}

/**
 * NOK
 * @param toys
 * @returns
 */
function groupToys2(toys: Toy[]): GroupedToys4 {
	const grouped: GroupedToys4 = {
		boardgames: [],
		dolls: [],
		puzzles: [],
	}
	toys.forEach((el) => {
		if (el.kind == "boardgame") {
			grouped[`${el.kind}s` as const].push(el)
		}
		// missing cases, defeats the purpose
	})
	return grouped
}

function groupToys3(toys: Toy[]): GroupedToys4 {
	const grouped: GroupedToys4 = {
		boardgames: [],
		dolls: [],
		puzzles: [],
	}
	toys.forEach((el) => {
		toys.forEach((el) => {
			grouped[`${el.kind}s` as const].push(el as any) // (nok) Type 'BoardGame' is not assignable to type 'never'.ts(2345)
		})
	})
	return grouped
}
